- 어떤 상황에서 **낙관적 업데이트(OptimisticUpdate)가 효율적일까요? 🍠**
    
    # 어떤 상황에서 **낙관적 업데이트(OptimisticUpdate)가 효율적일까요? 🍠**
    
    ---
    
    > **낙관적 업데이트(OptimisticUpdate)가 효율적인 상황은 언제일까요? 🍠**
    > 
    
    <aside>
    📌
    
    낙관적 업데이트는 사용자에게 즉각적으로 피드백을 제공하여 시용자 경험을 크게 향상시키기 때문에 효율적입니다. 따라서 이는 서버 요청의 성공 가능성이 높고, 사용자 경험 개선이 중요한 상황에서 효율적입니다. 
    
    1. 사용자 경험 개선이 중요한 경우
        - 사용자의 인터랙션에 즉각적인 피드백을 제공하여 애플리케이션이 더 빠르고 반응성이 좋은 것처럼 느끼도록 할 때 효율적
    2. 데이터의 충돌 가능성이 낮은 경우
        - 데이터베이스 트랜잭션에서 낙관적 동시성 제어는 여러 사용자가 동일한 데이터를 동시에 수정할 가능성이 적을 때 성능 상 좋음
    3. 네트워크의 지연이 발생 가능한 경우
        - 서버 응답을 기다리는 시간이 길어질 수 있는 환경에서 사용자가 지연 없이 작업을 계속할 수 있도록 할 때 유용
    </aside>
    
    > **낙관적 업데이트(OptimisticUpdate)를 피해야 하는 상황 언제일까요? 🍠**
    > 
    
    <aside>
    📌
    
    1. 데이터 일관성이 매우 중요한 경우
        - 데이터의 정확성과 일관성이 최우선인 애플리케이션에서는 사용을 지양하는 것이 좋음
    2. 실패 가능성이 높은 작업
        - 서버 오류, 유효성 검사 실패 등의 이유로 작업이 실패할 가능성이 높을 때는 낙관적 업데이트를 피하는 것이 좋음
    3. 롤백이 복잡하거나 불가능한 경우
        - 낙관적 업데이트 실패 시 이전 상태로 롤백하는 로직이 필수
    4. 동시성 문제 발생 가능성이 높은 경우
        - 여러 사용자가 동일한 데이터를 동시에 수정하여 충돌이 자주 발생하는 환경에서는 데이터 불일치 가능성이 커짐
    </aside>
    
- **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
    
    # **낙관적 업데이트(OptimisticUpdate) 블로그 읽고 개념 정리하기 🍠**
    
    ---
    
    [개발자 매튜 | 실제 서비스에서 낙관적 업데이트(Optimistic Update)를 활용하여, 유저의 답답함 줄이기](https://www.yolog.co.kr/post/optimistic-update)
    
    - **낙관적 업데이트(OptimisticUpdate)**를 왜 도입해야 하는지, 이 패턴이 해결하려는 문제를 실제 서비스 맥락에서 설명해보세요.
        1. **빠른 사용자 경험 제공** : 데이터가 서버에 전송되고 처리되기를 기다리지 않고 UI 를 즉시 업데이트하여서 더 빠른 응답성을 제공한다.
        2. **자연스러운 상호작용** : 사용자는 변경 사항이 즉시 반영된다고 느끼므로 더 자연스러운 애플리케이션 사용이 가능하다.
        3. **복잡한 상태 관리 간소화** : 상태가 즉시 반영되므로 비동기 작업 동안의 중간 상태를 관리하는 부담이 줄어든다.
    - TanStack Query 기반 구현 흐름을 `onMutate → (mutate) → onError → onSettled` 순서로 기술해주세요..
        1. **`onMutate` 로 낙관적 업데이트 처리**
            
            `onMutate` 는 `mutate` 함수가 호출될 때 가장 먼저 실행된다. 이 단계에서 우리는 기존 데이터를 기반으로 UI 를 즉시 업데이트하고 업데이트 이전의 데이터를 저장해 두어서 필요 시 복원할 수 있다.
            
            ```tsx
            onMutate : async (newTodo) => {
            	console.log(newTodo);
            	
            	// 기존 쿼리를 취소하여 race condition 방지
            	await queryClient.cancelQuries({ 
            		queryKey : todoKeys.todos._def
            	});
            	
            	// 기존 데이터를 가져와 constext 에 저장
            	const previousTodos = queryClient.getQueryData<TGetAllTodosResponse>(
            		todoKeys.todos.getAll().queryKey
            	)
            	
            	// 쿼리 데이터를 낙관적으로 업데이트
            	queryClient.setQueryData(
            		todoKeys.todos.getAll().queryKey,
            		(oldQueryData : TGetAllTodosResponse) => {
            			return {
            				...oldQueryData,
            				data : {
            					...oldQueryData.data,
            					todos : [{
            						...newTodo,
            						done : false, // 새로 추가된 TODO 는 기본적으로 완료되지 않은 상태
            					}],
            					......oldQueryData.data.todos,
            				}
            			}
            		}
            	)
            	
            	// 기존 데이터를 반환하여 context 로 저장
            	return { previousTodos }
            }
            ```
            
        2. **에러 발생 시 상태 복구**
            
            `onError` 는 API 호출이 실패했을 때 실행된다. 이 단계에서는 `onMutate` 단계에서 저장한 이전 데이터를 사용하여 상태를 복원한다.
            
            ```tsx
            onError : (error, _todo, context) => {
            	console.log(error);
            	
            	queryClient.setQueryData<TGetAllTodosResponse> (
            		todoKeys.todos.getAll().queryKey,
            		context?.previousTodos // 저장된 이전 데이터로 복원
            	)
            }
            ```
            
        3. **최종 작업 처리**
            
            onSettled 는 작업이 성공하거나 실패한 후 항상 호출된다. 이 단계에서 우리는 쿼리를 무효화하여 서버 데이터를 최신 상태로 동기화한다.
            
            ```tsx
            onSettled : () => {
            	queryClient.invalidateQuries({
            		queryKey : todoKeys.todos._def,
            	})
            }
            ```
            
    - ToDo “생성” 및 “좋아요 토글”에 **낙관적 업데이트(OptimisticUpdate)**를 적용했을 때의 **실패/충돌 롤백 전략**을 설계해주세요.
        - ToDo 생성 롤백 전략
            1. 낙관적 실행
                - 사용자 :  새 할 일 입력 후 추가 버튼 클릭
                - UI (즉시) : 입력창을 비우고 임시 ID 를 가진 할 일 항목을 ToDo 목록 상단에 즉시 추가합니다. 시각적으로는 처리 중임을 알 수 있도록 처리.
                - 백그라운드 (동시) : `POST /api/todos (body : { text : 할 일 })` 요청을 서버로 전송
            2. 서버 응답 처리
                - 성공 시 : 서버가 `201 created` 와 함께 실제 DB 에 저장된 ToDo 객체 반환
                    - UI 동기화 : 로컬 상태에서 임시 ID 를 가진 항목을 서버가 반환한 객체로 교체
                    - 처리 중으로 표기하던 UI 를 제거
                - 실패 시 : 서버가 400, 500 에러 또는 네트워크 타임아웃 발생 (롤백 시작)
            3. 실패 시 롤백
                - UI 롤백 : 목록에서 처리 중이던 임시 항목을 제거
                - 사용자 피드백 (필수) : 할 일 추가에 실패했다는 걸 알 수 있는 에러 메시지 띄움
                - 사용자 경험 복원 (중요) : 사용자가 다시 입력하는 수고를 덜도록 비웠던 입력창에 사용자가 입력했던 할 일 텍스트를 다시 채움
            
            추가 ) 충돌 시나리오 : 중복된 할 일
            
            - 서버 응답 : `409 conflict`
            - 롤백 전략 : 위의 1, 3 단계 동일 수행 후 에러 메시지를 다르게 제공
            
        - 좋아요 토글 롤백 전략
            1. 낙관적 실행
                - 사용자 :  ToDo 의 빈 하트를 클릭
                - UI (즉시) : 즉시 해당 ToDo 의 아이콘을 채워진 하트로 변경 후 좋아요 카운트 1 증가 시킴
                - 백그라운드 (동시) : `POST /api/todos/3/like` 요청을 서버로 전송
            2. 서버 응답 처리
                - 성공 시 : 서버가 `201 OK` 와 함께 갱신된 좋아요 상태 및 최신 카운트 반환
                    - UI 동기화 : 서버가 준 최신 카운트로 로컬 상태를 덮어씌워 정합성 보장
                - 실패 시 : 서버가 400, 500 에러 또는 네트워크 타임아웃 발생 (롤백 시작)
            3. 실패 시 롤백
                - UI 롤백 : 채워진 하트를 다시 빈 하트로 되돌린 후 좋아요 카운트 감소 (낙관적 실행 이전의 상태로 복원)
                - 사용자 피드백 (필수) : 좋아요 처리에 실패했다는 스낵바 메시지 띄움
                
            
            추가 ) 충돌 시나리오 : 삭제된 게시물에 좋아요
            
            - 서버 응답 : 404 not found
            - 롤백 전략 : 단순히 좋아요만 롤백하는 것이 아닌 더 큰 범위의 롤백 필요
                - UI 롤백 : 목록에서 해당 ToDo 항목 자체를 제거
                - 사용자 피드백 : 해당 항목은 이미 삭제되었다고 표시
            
            추가 ) 충돌 시나리오 : 동시 다발적 좋아요
            
            - 낙관적 실행 : 내 UI 는 1 만큼 증가시킴
            - 서버 응답 : 200 OK 와 함께 다른 사람이 증가시킨 카운트를 합산해서 반환
            - 강제 동기화 : 실패는 아니지만 충돌이기에 UI 는 11 에서 16 으로 서버의 데이터를 즉시 강제로 덮어씌워 (sync) 정합성을 맞춤